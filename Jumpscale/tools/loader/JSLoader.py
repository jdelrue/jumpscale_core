import os
import sys
import importlib
import json
import fcntl
import pystache
from subprocess import Popen, PIPE
from ...core.JSBase import JSBase

import importlib
import functools
import types

import importlib.util

# for monkey-patching the j instance to add namespace... "things"
patchers = [
    {'from': 'application', 'to': 'core.application'},
    {'from': 'dirs', 'to': 'core.dirs'},
    {'from': 'errorhandler', 'to': 'core.errorhandler'},
    {'from': 'exceptions', 'to': 'core.errorhandler.exceptions'},
    {'from': 'events', 'to': 'core.events'},
    {'from': 'data.datacache', 'to': 'data.cache'},
    {'from': 'logging', 'to': 'core.logging'},
    {'from': 'core.state', 'to': 'tools.executorLocal.state'},
]

def lazyprop(fn):
    attr_name = '_lazy_' + fn.__name__

    @property
    @functools.wraps(fn)
    def _lazyprop(self):
        if not hasattr(self, attr_name):
            setattr(self, attr_name, fn(self))
        return getattr(self, attr_name)

    return _lazyprop

def removeDirPart(path):
    "only keep part after jumpscale or digitalme"
    state = 0
    res = []
    for item in path.split("/"):
        if state == 0:
            if item.find("Jumpscale") != - \
                    1 or item.find("DigitalMe") != -1:
                state = 1
        if state == 1:
            res.append(item)
    if len(res) < 2:
        raise RuntimeError("could not split path in jsloader")
    if res[0] == res[1]:
        if res[0].casefold().find("jumpscale") != - \
                1 or res[0].casefold().find("digitalme") != -1:
            res.pop(0)
    return "/".join(res)


GEN_START = """\
# this code is auto-generated by jumpscale_core Jumpscale.tools.loader.JSLoader
# do not hand-edit

from Jumpscale.core.JSBase import JSBase
import os
os.environ["LC_ALL"]='en_US.UTF-8'
from Jumpscale import j

import functools

def lazyprop(fn):
    attr_name = '_lazy_' + fn.__name__

    @property
    @functools.wraps(fn)
    def _lazyprop(self):
        if not hasattr(self, attr_name):
            setattr(self, attr_name, fn(self))
        return getattr(self, attr_name)

    return _lazyprop

"""

IMPORTFN = r"""
def {0}:
    from {1} import {2}
    return {2}()
"""

GEN = """
{{#locationsubserror}}
{{classname}}=JSBase
{{/locationsubserror}}

class {{jname}}(JSBase):

    def __init__(self):
        {{#locationsubs}}
        self._{{name}} = None
        {{/locationsubs}}

    {{#locationsubs}}
    @property
    def {{name}}(self):
        if self._{{name}} is None:
            # print("PROP:{{name}}")
            from {{importlocation}} import {{classname}} as {{classname}}
            self._{{name}} = {{classname}}()
        return self._{{name}}

    {{/locationsubs}}

{{#locationsubs}}
if not hasattr(j.{{jname}},"{{name}}"):
    j.{{jname}}._{{name}} = None
    j.{{jname}}.__class__.{{name}} = {{jname}}.{{name}}
{{/locationsubs}}


 """

GEN2 = r"""
{{#locationsubserror}}
{{classname}}=JSBase
{{/locationsubserror}}

{{#locationsubs}}
def {{classprefix}}{{classname}}():
    from {{importlocation}} \
                            import {{classname}} \
                            as _{{classname}}
    return _{{classname}}()

{{/locationsubs}}

class {{jname}}(JSBase):

    {{#locationsubs}}
    @lazyprop
    def {{name}}(self):
        return {{classprefix}}{{classname}}()
    {{/locationsubs}}

"""


# Nothing needed at end for when used interactively
GEN_END = """

"""


# CODE GENERATION ONLY
GEN_END2 = r"""

class Jumpscale(JSBase):

    {{#locations}}
    @lazyprop
    def {{name}}(self):
        return {{name}}()
    {{/locations}}

# test code seeing if dynamic loader works live (which it does!)
if os.environ.get('JUMPSCALEMODE') == 'STATICLOADER':
    j = Jumpscale()
else:
    from Jumpscale.tools.loader.JSLoader import JSLoader
    DJ = JSBase._jsbase(j, 'JSLoader', [JSLoader])
    jl = DJ()
    j = jl.dynamic_generate(basej=j)
j.j = j # patch the (new) global j instance to know itself (zennnn.....)

def attrchecker(j, pth):
    pth = pth.split(".")
    for p in pth:
        nj = getattr(j, p, None)
        if nj is None:
            return False
        j = nj
    return True

{{#patchers}}
if not attrchecker(j, "{{from}}"):
    j.{{from}} = j.{{to}}
{{/patchers}}

# sigh need to do this as LoggerFactory is not yet inherited from JSBase
# (neither are JSLogger instances, but they all look at their parent_
j.logging.j = j
j.cache = j.data.cache

def profileStart():
    import cProfile
    pr = cProfile.Profile()
    pr.enable()
    return pr

def profileStop(pr):
    pr.disable()
    import io
    import pstats
    s = io.StringIO()
    sortby = 'cumulative'
    ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
    ps.print_stats()
    print(s.getvalue())

j._profileStart = profileStart
j._profileStop = profileStop

"""

setup_cmd = r"""\
from setuptools import setup

setup(
    name='jumpscale',
    py_modules=['jumpscale'],
)
"""


def setNonBlocking(fd):
    """
    Set the file description of the given file descriptor to non-blocking.
    """
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    flags = flags | os.O_NONBLOCK
    fcntl.fcntl(fd, fcntl.F_SETFL, flags)


def readwrite(p, sendto):
    out1 = ''
    p.stdin.write(sendto.encode())
    while True:
        try:
            out = p.stdout.read()
            if out is None:
                break
            out1 += out.decode('utf-8')
        except IOError:
            continue
        else:
            break
    err = p.stderr.read()  # deliberately block on stderr to wait for cmd
    out = p.stdout.read()  # read last of cmd
    if out:
        out1 += out.decode('utf-8')
    return out1


def pipecmd(cmd, cwd, sendto):
    p = Popen(cmd, cwd=cwd,
              stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=1)
    setNonBlocking(p.stdout)
    # setNonBlocking(p.stderr)
    out = readwrite(p, sendto)
    print ("pipecmd")
    print(out)


def jumpscale_py_setup(location):
    """ installs jumpscale.py from directory <location> by
        creating, then running, then deleting, a jscale_setup.py
        in the same subdirectory.

        --old-and-unmanageable is the rather arrogant name
        given by the python developers to the way to get
        setuptools to stop putting python files into .eggs
        where you then can't edit them and check what they do
    """
    cwd = os.getcwd()
    os.chdir(location)
    setup_script = os.path.join(location, "jscale_setup.py")
    with open(setup_script, "w") as f:
        f.write(setup_cmd)
    pipecmd(["/usr/bin/env", "python3", setup_script,
             "install", "--old-and-unmanageable", "--force"],
             location, "")
    # os.unlink(setup_script)
    os.chdir(cwd)


class JSLoader():

    def __init__(self):
        self.__jslocation__ = "j.tools.jsloader"
        self.tryimport = False
        self._logger = None

    @property
    def logger(self):
        if self._logger is None:
            self._logger = self.j.logging.get("jsloader")
        return self._logger

    @property
    def autopip(self):
        return self.j.core.state.config["system"]["autopip"] in [
            True, "true", "1", 1]

    def _installDevelopmentEnv(self):
        cmd = "apt-get install python3-dev libssl-dev -y"
        self.j.sal.process.execute(cmd)
        self.j.sal.process.execute("pip3 install pudb")

    def _findSitePath(self):
        res = ""
        for item in sys.path:
            if "/site-packages" in item:
                if res == "" or len(item) < len(res):
                    res = item
        if res != "":
            return res
        for item in sys.path:
            if "/dist-packages" in item:
                if res == "" or len(item) < len(res):
                    res = item
        if res == "":
            raise RuntimeError("Could not find sitepath")
        return res

    @property
    def initPath(self):
        path = self._findSitePath() + "/jumpscale.py"
        # print("initpath:%s" % path)
        self.j.sal.fs.remove(path)

        return path

    def _pip(self, item):
        rc, out, err = self.j.sal.process.execute(
            "pip3 install %s" %
            item, die=False)
        if rc > 0:
            if "gcc' failed" in out:
                self._installDevelopmentEnv()
                rc, out, err = self.j.sal.process.execute(
                    "pip3 install %s" % item, die=False)
        if rc > 0:
            print("WARNING: COULD NOT PIP INSTALL:%s\n\n" % item)
        return rc

    def processLocationSub(self, jlocationSubName, jlocationSubList):
        # import a specific location sub (e.g. j.clients.git)

        classfile, classname, importItems = jlocationSubList

        generationParamsSub = {}
        generationParamsSub["classname"] = classname
        generationParamsSub["name"] = jlocationSubName
        importlocation = removeDirPart(
            classfile)[:-3].replace("//", "/").replace("/", ".")
        generationParamsSub["importlocation"] = importlocation
        prefix = importlocation.split('.')[:-1]
        prefix = map(lambda x: x[0].upper()+x[1:], prefix)
        prefix = ''.join(prefix)
        generationParamsSub["classprefix"] = prefix

        rc = 0

        return rc, generationParamsSub

    def gather_modules(self):
        """ identifies and gathers information about (only) jumpscale modules
        """
        # outCC = outpath for code completion
        # out = path for core of jumpscale

        # make sure the jumpscale toml file is set / will also link cmd files
        # to system
        self.j.tools.executorLocal.initEnv()

        moduleList = {}
        baseList = {}

        for name, path in self.j.tools.executorLocal.state.configGet(
                'plugins', {}).items():
            self.logger.info("find modules in jumpscale for : '%s'" % path)
            if self.j.sal.fs.exists(path, followlinks=True):
                if False: # XXX hmmm.... nasty hack... disable....
                    pth = path
                    if pth[-1] == '/':
                        pth = pth[:-1]
                    pth = os.path.split(pth)[0]
                    sys.path = [pth] + sys.path
                moduleList, baseList = self.findModules(path=path,
                                        moduleList=moduleList,
                                        baseList=baseList)
            else:
                raise RuntimeError("Could not find plugin dir:%s" % path)
                # try:
                #     mod_path = importlib.import_module(name).__path__[0]
                #     moduleList = self.findModules(path=mod_path)
                # except Exception as e:
                #     pass

        for jlocationRoot, jlocationRootDict in moduleList.items():
            # is per item under j e.g. self.j.clients

            if not jlocationRoot.startswith("j."):
                raise RuntimeError(
                    "jlocation should start with j, found: '%s', in %s" %
                    (jlocationRoot, jlocationRootDict))

            for subname, sublist in jlocationRootDict.items():
                rc, _ = self.processLocationSub(subname, sublist)
                if rc != 0:
                    # remove unneeded items
                    del jlocationRootDict[subname]

        return moduleList, baseList

    def _dynamic_generate(self, basej):
        """ dynamically generates a jumpscale instance.

            uses gather_modules (which strips out non-Jumpscale modules for us)
            to get a list of root (base) modules that are in __init__.py
            files (and have a __jslocation__), and submodules that need
            to be added to them.

            base (root) instance constructors are **REQUIRED** to not
            have side-effects: they get instantiated straight away
            (see use of m.getter() below).

            anything else gets created as a lazy-property
            (see BaseGetter __getattribute__ override, they
             end up in BaseGetter.__subgetters__)
        """

        # gather list of modules (also initialises environment)
        moduleList, baseList = self.gather_modules()

        _j = basej._create_jsbase_instance('Jumpscale')

        for jlocationRoot, jlocationRootDict in moduleList.items():
            jname = jlocationRoot.split(".")[1].strip()
            #print ("dynamic generate root", jname, jlocationRoot)
            if jlocationRoot in baseList:
                kls = baseList[jlocationRoot]
                m = _j._add_instance(jname, "Jumpscale."+jname, kls, basej=_j)
                member = m.getter()
                #print ("baselisted", jname, member)
            else:
                member = JSBase._create_jsbase_instance(jname)
                setattr(_j, jname, member)
            for subname, sublist in jlocationRootDict.items():
                modulename, classname, imports = sublist
                #print ("subs", jlocationRoot, subname, sublist)
                importlocation = removeDirPart(
                    modulename)[:-3].replace("//", "/").replace("/", ".")
                #print (importlocation)
                member._add_instance(subname, importlocation, classname,
                                     fullpath=modulename,
                                     basej=basej)

        for p in patchers:
            #print ("patching", p)
            frommodule = p['from']
            walkfrom = _j
            frommodule = frommodule.split('.')
            for fromname in frommodule[:-1]:
                #print ("patchfrom", walkfrom, fromname)
                walkfrom = getattr(walkfrom, fromname)
            child = frommodule[-1]
            walkto = _j
            module = p['to']
            for subname in module.split('.'):
                #print ("patchto", walkto, subname)
                walkto = getattr(walkto, subname)
            setattr(walkfrom, child, walkto)

        #print (dir(_j))
        #print (dir(_j.core))
        #print (type(_j.core.errorhandler))
        #print (dir(_j.core.errorhandler))
        #_j.application = _j.core().application
        #_j.exceptions = _j.core().errorhandler().exceptions

        _j.j = _j

        return _j

    def _generate(self):
        """ generates the jumpscale init file: jumpscale
            as well as the one required for code generation

            to call:
            ipython -c 'from Jumpscale import j;j.tools.jsloader.generate()'
        """

        # gather list of modules (also initialises environment)
        moduleList, baseList = self.gather_modules()

        # outCC = outpath for code completion
        # out = path for core of jumpscale

        outCC = os.path.join(self.j.dirs.HOSTDIR, "autocomplete", "jumpscale.py")
        outJSON = os.path.join(
            self.j.dirs.HOSTDIR,
            "autocomplete",
            "jumpscale.json")
        self.j.sal.fs.createDir(os.path.join(self.j.dirs.HOSTDIR, "autocomplete"))

        out = self.initPath
        self.logger.info("* jumpscale path:%s" % out)
        self.logger.info("* jumpscale codecompletion path:%s" % outCC)
        self.initPath  # to make sure empty one is created

        content = GEN_START
        contentCC = GEN_START

        jlocations = {}
        jlocations["locations"] = []

        modlistout_json = json.dumps(moduleList, sort_keys=True, indent=4)
        self.j.sal.fs.writeFile(outJSON, modlistout_json)

        for jlocationRoot, jlocationRootDict in moduleList.items():
            # is per item under j e.g. j.clients

            if not jlocationRoot.startswith("j."):
                raise RuntimeError(
                    "jlocation should start with j, found: '%s', in %s" %
                    (jlocationRoot, jlocationRootDict))

            jlocations["locations"].append({"name": jlocationRoot[2:]})
            jlocations["patchers"] = patchers

            generationParams = {}
            generationParams["locationsubserror"] = []
            generationParams["jname"] = jlocationRoot.split(
                ".")[1].strip()  # only name under j e.g. tools
            generationParams["locationsubs"] = []

            # add per sublocation to the generation params
            for jlocationSubName, jlocationSubList in jlocationRootDict.items():
                rc, generationParamsSub = self.processLocationSub(
                                    jlocationSubName, jlocationSubList)
                generationParams["locationsubs"].append(generationParamsSub)

            # put the content in
            content0CC = pystache.render(GEN2, **generationParams)
            content0 = pystache.render(GEN, **generationParams)
            if len([item for item in content0CC.split(
                    "\n") if item.strip() != ""]) > 4:
                contentCC += content0CC
            if len([item for item in content0.split(
                    "\n") if item.strip() != ""]) > 4:
                content += content0

        contentCC += pystache.render(GEN_END2, **jlocations)
        content += pystache.render(GEN_END, **jlocations)

        self.logger.info("wrote jumpscale autocompletion file in %s" % outCC)
        self.j.sal.fs.writeFile(outCC, contentCC)

        self.logger.info("installing jumpscale.py file using setuptools")
        autodir = os.path.join(self.j.dirs.HOSTDIR, "autocomplete")
        jumpscale_py_setup(autodir)

    def _pip_installed(self):
        "return the list of all installed pip packages"
        import json
        _, out, _ = self.j.sal.process.execute(
            'pip3 list --format json', die=False, showout=False)
        pip_list = json.loads(out)
        return [p['name'] for p in pip_list]

    def findJumpscaleLocationsInFile(self, path):
        """
        returns:
            [$classname]["location"] =$location
            [$classname]["import"] = $importitems
        """
        res = {}
        C = self.j.sal.fs.readFile(path)
        classname = None
        locfound = False
        for line in C.split("\n"):
            if line.startswith("class "):
                classname = line.replace(
                    "class ", "").split(":")[0].split(
                    "(", 1)[0].strip()
                if classname == "JSBaseClassConfig":
                    break
            if line.find("self.__jslocation__") != -1 and locfound == False:
                if classname is None:
                    raise RuntimeError(
                        "Could not find class in %s " +
                        "while loading jumpscale lib." %
                        path)
                location = line.split(
                    "=",
                    1)[1].replace(
                    "\"",
                    "").replace(
                    "'",
                    "").strip()
                if location.find("self.__jslocation__") == -1:
                    if classname not in res:
                        res[classname] = {}
                    res[classname]["location"] = location
                    locfound = True
                    self.logger.debug("%s:%s:%s" % (path, classname, location))
            if line.find("self.__imports__") != -1:
                if classname is None:
                    raise RuntimeError(
                        "Could not find class in %s " +
                        "while loading jumpscale lib." %
                        path)
                importItems = line.split(
                    "=",
                    1)[1].replace(
                    "\"",
                    "").replace(
                    "'",
                    "").strip()
                importItems = [
                    item.strip() for item in importItems.split(",")
                    if item.strip() != ""]
                if classname not in res:
                    res[classname] = {}
                res[classname]["import"] = importItems

        return res

    # import json

    def findModules(self, path, moduleList=None, baseList=None):
        """ walk over code files & find locations for jumpscale modules
            return as two dicts.

            format of moduleList:
            [$rootlocationname][$locsubname]=(classfile,classname,importItems)

            format of baseList:
            [$rootlocationname]=(classname,jlocation)
        """
        # self.logger.debug("modulelist:%s"%moduleList)
        if moduleList is None:
            moduleList = {}
        if baseList is None:
            baseList = {}

        self.logger.info("findmodules in %s" % path)

        for classfile in self.j.sal.fs.listFilesInDir(path, True, "*.py"):
            # print(classfile)
            basename = self.j.sal.fs.getBaseName(classfile)
            if basename.startswith('__init__'):
                for classname, item in self.findJumpscaleLocationsInFile(
                        classfile).items():
                    #print ("found", classfile, classname, item)
                    # hmm probably can use moduleList but not sure...
                    if "location" not in item:
                        continue
                    location = item["location"]
                    baseList[location] = classname

            if basename.startswith("_"):
                continue
            if "actioncontroller" in basename.lower():
                continue
            # look for files starting with Capital
            if str(basename[0]) != str(basename[0].upper()):
                continue

            for classname, item in self.findJumpscaleLocationsInFile(
                    classfile).items():
                # item has "import" & "location" as key in the dict
                if "location" not in item:
                    continue
                location = item["location"]
                if "import" in item:
                    importItems = item["import"]
                else:
                    importItems = []

                locRoot = ".".join(location.split(".")[:-1])
                locSubName = location.split(".")[-1]
                if locRoot not in moduleList:
                    moduleList[locRoot] = {}
                moduleList[locRoot][locSubName] = (
                    classfile, classname, importItems)
        return moduleList, baseList

    def removeEggs(self):
        for key, path in self.j.clients.git.getGitReposListLocal(
                account="jumpscale").items():
            for item in [item for item in self.j.sal.fs.listDirsInDir(
                    path) if item.find("egg-info") != -1]:
                self.j.sal.fs.removeDirTree(item)

    def _copyPyLibs(self, autocompletepath=None):
        """
        this looks for python libs (non jumpscale) and copies them to our gig
        lib dir which can be use outside of docker for e.g. code completion

        NOT NEEDED NOW
        """
        if autocompletepath is None:
            autocompletepath = os.path.join(self.j.dirs.HOSTDIR, "autocomplete")
            self.j.sal.fs.createDir(autocompletepath)

        for item in sys.path:
            if item.endswith(".zip"):
                continue
            if "jumpscale" in item.lower() or "dynload" in item.lower():
                continue
            if 'home' in sys.path:
                continue
            if item.strip() in [".", ""]:
                continue
            if item[-1] != "/":
                item += "/"

            if self.j.sal.fs.exists(item, followlinks=True):
                self.j.sal.fs.copyDirTree(item,
                                     autocompletepath,
                                     overwriteFiles=True,
                                     ignoredir=['*.egg-info',
                                                '*.dist-info',
                                                "*Jumpscale*",
                                                "*Tests*",
                                                "*tests*"],

                                     ignorefiles=['*.egg-info',
                                                  "*.pyc",
                                                  "*.so",
                                                  ],
                                     rsync=True,
                                     recursive=True,
                                     rsyncdelete=False,
                                     createdir=True)

        self.j.sal.fs.writeFile(
            filename=os.path.join(
                autocompletepath,
                "__init__.py"),
            contents="")

    def prepare_config(self, autocompletepath=None):
        """ prepares the plugin configuration
        """

        if self.j.dirs.HOSTDIR == "":
            raise RuntimeError(
                "dirs in your jumpscale.toml not ok, hostdir cannot be empty")

        if autocompletepath is None:
            autocompletepath = os.path.join(self.j.dirs.HOSTDIR, "autocomplete")
            self.j.sal.fs.createDir(autocompletepath)

        for name, path in self.j.core.state.configGet('plugins', {}).items():
            if self.j.sal.fs.exists(path, followlinks=True):
                # link libs to location for hostos
                self.j.sal.fs.copyDirTree(path,
                                     os.path.join(autocompletepath, name),
                                     overwriteFiles=True,
                                     ignoredir=['*.egg-info',
                                                '*.dist-info',
                                                "*Jumpscale*",
                                                "*Tests*",
                                                "*tests*"],

                                     ignorefiles=['*.egg-info',
                                                  "*.pyc",
                                                  "*.so",
                                                  ],
                                     rsync=True,
                                     recursive=True,
                                     rsyncdelete=True,
                                     createdir=True)

        self.j.sal.fs.touch(os.path.join(self.j.dirs.HOSTDIR, 'autocomplete',
                "__init__.py"))

        # DO NOT AUTOPIP the deps are now installed while installing the libs
        self.j.core.state.configSetInDictBool("system", "autopip", False)
        # j.application.config["system"]["debug"] = True

    def generate(self, autocompletepath=None):
        """
        """

        self.prepare_config(autocompletepath)
        self._generate()

    def dynamic_generate(self, autocompletepath=None, basej=None):
        """
        """
        assert basej is not None
        self.prepare_config(autocompletepath)
        return self._dynamic_generate(basej)
