#!/usr/bin/env python3
""" starts an (insecure!!) remote python execution environment.

    can be easily made much more secure: ssl, ssh, etc.

    runs on port 18861, sets up log file (rjumpscale.log),
    and runs as a background daemon (pid file rjumpscale.pid).

    for the zero-deploy remote version, which can be
    executed over ssh and will automatically copy files
    over to start running jumpscale over a remote connection.
"""

import daemon
from lockfile.pidlockfile import PIDLockFile
import sys
import signal
import os
from rpyc.utils.server import ForkingServer
from rpyc.core.service import SlaveService
from rpyc.lib import setup_logger
from Jumpscale import jumpscale

server = None
cur_dir = os.getcwd()
bin_dir = os.path.dirname(__file__)

class JumpscaleService(SlaveService):
    _j = None
    def on_connect(self, conn):
        super(JumpscaleService, self).on_connect(conn)
        print ("connection", conn)

    def on_disconnect(self, conn):
        super(JumpscaleService, self).on_disconnect(conn)
        print ("disconnect", conn)

    @property
    def j(self):
        if self._j is None:
            # deliberately put this in the local class scope
            j = Jumpscale()
            self._j = j
        return self._j

def start():
    global server

    factory = ForkingServer
    logfile = os.path.join(cur_dir, "rjumpscale.log")
    setup_logger(True, logfile)

    server = factory(JumpscaleService, port=18861, reuse_addr = True,
                     authenticator=None)
    server.start()

def reload(*args):
    server.close()
    start()

def stop(*args):
    server.close()
    sys.exit()

if __name__ == "__main__":
    if len(sys.argv) > 1: # quick hack to run in foreground
        start()
        exit(0)
    pid_file = os.path.join(cur_dir, 'rjumpscale.pid')
    with daemon.DaemonContext(
            pidfile = PIDLockFile(pid_file),
            signal_map = {signal.SIGTERM: stop, signal.SIGHUP: reload}):
        start()
